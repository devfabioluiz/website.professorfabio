<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Evolução do ECMAScript</title>
    <link rel="stylesheet" href="../../estilos/estilos-aulas.css" />
  </head>
  <body>
    <header>
      <h1>Aula 5</h1>
      <h4 style="text-align: center">JavaScript Intermediário</h4>
      <h4 style="text-align: center">
        EcmaScript (parte 1 - Definição, Versões e Arrow Function)
      </h4>
    </header>
    <main class="container">
      <h2>ECMAScript</h2>
      <section>
        <p>
          O ECMAScript (ES) é a especificação que define as linguagens de
          script, como o JavaScript. Ele tem evoluído desde sua criação em 1997
          para incluir novos recursos e funcionalidades que atendem às demandas
          dos desenvolvedores modernos. Abaixo, apresento a evolução do
          ECMAScript, destacando suas principais versões e inovações.
        </p>
      </section>

      <h3>ECMAScript 1 (1997)</h3>
      <section>
        <ul>
          <li>Primeira versão da linguagem.</li>
          <li>
            Definiu a base do JavaScript, como tipos de dados, estruturas de
            controle, objetos padrão (como <code>Object</code>,
            <code>Array</code>, e <code>Date</code>) e funções.
          </li>
        </ul>
      </section>

      <h3>ECMAScript 2 (1998)</h3>
      <section>
        <ul>
          <li>
            Pequenas alterações para alinhar o ECMAScript ao padrão
            internacional ISO/IEC 16262.
          </li>
          <li>Sem grandes mudanças para desenvolvedores.</li>
        </ul>
      </section>

      <h3>ECMAScript 3 (1999)</h3>
      <section>
        <ul>
          <li>Tornou o JavaScript mais robusto e amplamente utilizado.</li>
          <li>
            <strong>Novidades:</strong>
            <ul>
              <li>
                Suporte a expressões regulares (veremos em aulas posteriores)
              </li>
              <li>
                Controle de exceções com
                <code>try/catch (veremos em aulas posteriores)</code>.
              </li>
              <li>Melhor manipulação de strings.</li>
              <li>
                Adição do modo estrito (strict mode). (veremos em aulas
                posteriores)
              </li>
            </ul>
          </li>
        </ul>
      </section>

      <h3>ECMAScript 4 (Cancelado)</h3>
      <section>
        <p>
          A proposta para esta versão era ambiciosa, incluindo tipagem estática
          e classes complexas, mas acabou sendo abandonada devido à falta de
          consenso.
        </p>
      </section>

      <h3>ECMAScript 5 (2009)</h3>
      <section>
        <ul>
          <li>
            Foco na melhoria de performance e na padronização do JavaScript.
          </li>
          <li>
            <strong>Novidades:</strong>
            <ul>
              <li>
                Suporte ao modo estrito (<code>"use strict"</code>). (veremos em
                aulas posteriores)
              </li>
              <li>
                Métodos úteis como <code>Array.prototype.map</code>,
                <code>filter</code>, <code>forEach</code>, e
                <code>reduce</code>.
              </li>
              <li>
                Propriedades imutáveis com <code>Object.defineProperty</code>.
              </li>
              <li>JSON nativo para manipulação de dados.</li>
            </ul>
          </li>
        </ul>
      </section>

      <h3>ECMAScript 6 (2015)</h3>
      <section>
        <p>
          Um marco na evolução do JavaScript, introduzindo recursos modernos.
        </p>
        <ul>
          <li>
            <strong>Novidades:</strong>
            <ul>
              <li>Sintaxe de classes (<code>class</code>).</li>
              <li>
                Declaração de variáveis com <code>let</code> e
                <code>const</code>.
              </li>
              <li>Arrow functions (<code>=></code>).</li>
              <li>Template literals (strings interpoladas com crases).</li>
              <li>Destructuring (<code>const {x, y} = obj</code>).</li>
              <li>Módulos (<code>import/export</code>).</li>
              <li>Promises para programação assíncrona.</li>
              <li>Operador spread/rest (<code>...</code>).</li>
            </ul>
          </li>
        </ul>
        <p>
          Veremos a seguir a explicação detalhada dessas mudanças tão
          significativas no JavaScript
        </p>
      </section>

      <h3>ECMAScript 7 (2016)</h3>
      <section>
        <li>Operador de Exponenciação (<code>**</code>)</li>
        <p>Uma forma simplificada de calcular potências.</p>
        <pre
          id="code"
        ><code class="language-javascript">console.log(2 ** 3); // 8</code></pre>
        <button class="btn-copy">Copiar Código</button>
</div>

        <li>Método <code>Array.prototype.includes</code></li>
        <p>Verifica se um valor está presente em um array.</p>
        <div class="code-container"><pre><code class="language-javascript">
const numeros = [1, 2, 3];
console.log(numeros.includes(2)); // true
console.log(numeros.includes(4)); // false
            </code></pre>
        <button class="btn-copy">Copiar Código</button>
</div>
      </section>

      <h3>ECMAScript 8 (2017)</h3>
      <section>
        <li><code>Object.values</code> e <code>Object.entries</code></li>
        <p>
          <strong>Object.values</strong>: Retorna os valores de um objeto.
          <strong>Object.entries</strong>: Retorna pares chave-valor como
          arrays.
        </p>
        <div class="code-container"><pre><code class="language-javascript">
const pessoa = { nome: "Maria", idade: 25 };
console.log(Object.values(pessoa)); // ["Maria", 25]
console.log(Object.entries(pessoa)); // [["nome", "Maria"], ["idade", 25]]
            </code></pre>
        <button class="btn-copy">Copiar Código</button>
</div>

        <li><code>String.prototype.padStart</code> e <code>padEnd</code></li>
        <p>Adiciona preenchimento no início ou no final de uma string.</p>
        <div class="code-container"><pre><code class="language-javascript">
console.log("5".padStart(3, "0")); // "005"
console.log("5".padEnd(3, "-")); // "5--"
            </code></pre>
        <button class="btn-copy">Copiar Código</button>
</div>

        <li><code>async/await (veremos em aulas posteriores)</code></li>
      </section>

      <h3>ECMAScript 9 (2018)</h3>
      <section>
        <ul>
          <li>Rest/Spread em Objetos (veremos em aulas posteriores)</li>

          <li>Promise.prototype.finally (veremos em aulas posteriores)</li>

          <li>
            Iteração Assíncrona (<code>for await...of</code>) (veremos em aulas
            posteriores)
          </li>
        </ul>
      </section>

      <h2>Arrow Function</h2>
      <section class="texto-imprimir">
        <p>
          Funções em JavaScript podem ser declaradas de diferentes formas, sendo
          as mais comuns a função normal e a arrow function. Ambas possuem
          diferenças importantes em sintaxe e comportamento.
        </p>
        <p>
          Funções de seta introduzem uma sintaxe curta para escrever funções.
          Além disso, elas não têm seu próprio <code>this</code>, herdando do
          contexto ao redor.
        </p>

        <h3>Sintaxe</h3>
        <p>
          A principal diferença inicial é a forma como as funções são escritas:
        </p>
        <ul>
          <li>
            <b>Função Normal:</b> É escrita com a palavra-chave
            <code>function</code>:
          </li>
        </ul>
        <div class="code-container"><pre>
          <code>
function soma(a, b) {
  return a + b;
}
console.log(soma(2, 3)); // Saída: 5
          </code>
        </pre>
        <button class="btn-copy">Copiar Código</button>
</div>
        <ul>
          <li>
            <b>Arrow Function:</b> Usa uma sintaxe mais curta, com
            <code>=></code>:
          </li>
        </ul>
        <div class="code-container"><pre>
          <code>
const soma = (a, b) => a + b;
console.log(soma(2, 3)); // Saída: 5
          </code>
        </pre>
        <button class="btn-copy">Copiar Código</button>
</div>

        <h3>Comportamento do <code>this</code></h3>
        <p>
          O comportamento do <code>this</code> é uma das principais diferenças:
        </p>
        <ul>
          <li>
            <b>Função Normal:</b> O <code>this</code> é dinâmico, dependendo do
            contexto em que a função foi chamada.
          </li>
        </ul>
        <div class="code-container"><pre>
          <code>
const obj = {
  valor: 10,
  funcaoNormal: function () {
    return this.valor;
  },
};
console.log(obj.funcaoNormal()); // Saída: 10
          </code>
        </pre>
        <button class="btn-copy">Copiar Código</button>
</div>
        <ul>
          <li>
            <b>Arrow Function:</b> O <code>this</code> é léxico, herdando o
            contexto onde a função foi definida.
          </li>
        </ul>
        <div class="code-container"><pre>
          <code class="language-javascript">
const obj = {
  valor: 10,
  arrowFunction: () => {
    return this.valor;
  },
};
console.log(obj.arrowFunction()); // Saída: undefined
          </code>
        </pre>
        <button class="btn-copy">Copiar Código</button>
</div>

        <h3>Uso como Construtor</h3>
        <p>Apenas funções normais podem ser usadas como construtores:</p>
        <div class="code-container"><pre>
          <code>
// Função Normal
function Pessoa(nome) {
  this.nome = nome;
}
const pessoa1 = new Pessoa("João");
console.log(pessoa1.nome); // Saída: João

// Arrow Function
const Pessoa = (nome) => {
  this.nome = nome;
};
const pessoa1 = new Pessoa("João"); // Erro: Pessoa não é um construtor
          </code>
        </pre>
        <button class="btn-copy">Copiar Código</button>
</div>
      </section>

      <h3>Explicação sobre o this</h3>
      <section>
        <p>
          A palavra-chave <code>this</code> representa o objeto ao qual a função
          atual pertence. Seu valor depende de onde e como a função foi chamada:
        </p>
        <ul>
          <li>
            Em um método de objeto, <code>this</code> refere-se ao objeto pai.
          </li>
          <li>
            Em uma função regular, <code>this</code> é <code>undefined</code> no
            modo estrito ou o objeto global fora dele.
          </li>
          <li>
            Em funções de seta, <code>this</code> é herdado do contexto lexical.
          </li>
        </ul>
      </section>
    </main>
    <footer>
      <div class="button-container">
        <button class="btn-print" onclick="window.print()">Imprimir</button>
      </div>
      <div class="button-container">
        <a class="btn-indice" href="../indice-step.html">Ir para o índice</a>
      </div>
    </footer>
    <script src="../../scripts/copy-clipboard.js"></script>
  </body>
</html>
